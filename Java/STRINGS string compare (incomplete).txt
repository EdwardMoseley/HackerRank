/*
Given a string, find out the lexicographically smallest and largest substring of length k.

[Note: Lexicographic order is also known as alphabetic order dictionary order. So "ball" is smaller than "cat", "dog" is smaller than "dorm". Capital letter always comes before smaller letter, so "Happy" is smaller than "happy" and "Zoo" is smaller than "ball".]
*/
 

import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;

public class Solution {
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        String str = sc.nextLine();
        int n = sc.nextInt();
        
        //int[] count = new int[str.length()+n-1];
        String[] tmp = new String[str.length()+n];
        String[] store = new String[str.length()+n-1];
        
        String tmpOne;
        String tmpTwo;
        
        int i = 0;
        int j = 0;
        int z = 0;
        
        while(str.substring(i,i+n).length() >= n){
            //tmpOne = str.substring(i,i+n)
            if (i == 0){
                store[i] = str.substring(i,i+n);
                i += 1; 
            } else {
                j = 0;
                if (str.substring(i,i+n).compareTo(store[j]) > 0 ){
                    System.out.println("We haven't found an imposter yet!");
                    j += 1; 
                } else {
                    store[j+1] = str.substring(i,i+n);
                    i += 1;
                }
                System.out.println("We've found an imposter!");
                tmp = Arrays.copyOfRange(store, j, store.length);
                store[j+1] = str.substring(i,i+n);
                z = 0;
                while (z <= tmp.length && tmp[z] != null && store[j+z+1] != tmp[z]){
                    store[j+z+1] = tmp[z];
                    z = z + 1;
                    System.out.println(Arrays.toString(store));
                }
            }
            System.out.println("This loop is over");
        }
        
        //String kaiou = "ZAA";
        //String ned = "AZZ";
        //System.out.println(ned.compareTo(kaiou));
                        // ned - kaiou
                        // if returns negative number, kaiou is lex bigger
        
        
                
        //System.out.println(Arrays.toString(store));
    }
}


// grab string && substring size
// while substring > substring size (removes duplicates and indices out of bounds)
//      compare substrings lexicographically (sp?) from left to right
//          if tmpOne string is higher on lex scale than substring[x]
//                tmpTwo = substring[x]
//                substring[x] = tmpOne
//                substring[x+1] = tmpTwo
//   once that stupid loop is done
//   return(substring[0]+"\n"+substring[substring.length()])
